#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Pentest ‚Äî Desserializa√ß√£o & Adjacent (standalone ++, com URLs e par√¢metros do WAF)

Cobertura (mantida + acrescida):
- CSRF (sem token) em rotas de formul√°rio
- Content-Type Enforcement (rotas JSON e FORM, inclui XML/YAML/octet)
- AJAX JSON (verifica retorno JSON sob X-Requested-With)
- Pickle Smuggling (payload bin√°rio/‚Äúpickle-like‚Äù em campo de texto)
- JSON Guard (tamanho, profundidade, chaves, entropia)
- Cookies/Headers (checagem b√°sica de presen√ßa / flags)
- ConfigCheck (observabilidade de SESSION_SERIALIZER via HTTP: N/A)

ACRESCIMOS (sem remover nada):
- Uso das MESMAS URLs: TEST_ENDPOINTS a partir de URLS_FROM_URLPATTERNS (override por PT_ENDPOINTS)
- Uso dos MESMOS PAR√ÇMETROS: PARAM_NAMES (override por PT_PARAM_NAMES)
- Varredura GET/POST/JSON por endpoint x par√¢metro (benignos e ‚Äúpickle-like‚Äù/invis√≠veis)
- POST real do formul√°rio de cria√ß√£o com `d_doc` (captura de CSRF)

Dicas de ENV:
  PT_BASE_URL, PT_LOGIN_URL, PT_VERIFY_TLS, PT_TIMEOUT
  PT_FORM_CREATE_ENDPOINT, PT_AJAX_LIST_ENDPOINT, PT_JSON_PROBE_ENDPOINT
  PT_ENDPOINTS (lista separada por v√≠rgula)
  PT_PARAM_NAMES (lista separada por v√≠rgula)
  PT_LOGIN, PT_PASSWORD, PT_LOGIN_FIELD, PT_PASSWORD_FIELD, PT_SESSIONID
"""

import os
import re
import csv
import json
import time
import base64
import random
import string
import hashlib
import requests
from urllib.parse import urljoin, urlparse, quote
from datetime import datetime, UTC
from collections import Counter

# =========================
# Configura√ß√£o via ambiente
# =========================

BASE_URL   = os.getenv("PT_BASE_URL", "http://localhost:8000/")
LOGIN_URL  = urljoin(BASE_URL, os.getenv("PT_LOGIN_URL", "login"))
VERIFY_TLS = os.getenv("PT_VERIFY_TLS", "false").lower() in ("1","true","yes")
TIMEOUT    = int(os.getenv("PT_TIMEOUT", "15"))

# Relat√≥rios
OUTPUT_JSON = os.getenv("PT_OUTPUT_JSON", "pentest_deserializacao_results.json")
OUTPUT_CSV  = os.getenv("PT_OUTPUT_CSV",  "pentest_deserializacao_results.csv")

# Endpoints "can√¥nicos" (mesmos do WAF) ‚Äî pode ajustar/estender aqui
URLS_FROM_URLPATTERNS = [
    "/administrador/documento",
    "/administrador/documento/cadastrar",
    "/administrador/documento/1/excluir/",
    "/administrador/documento/1/editar/",
    "/administrador/estabelecimento",
    "/administrador/anexos",
    "/administrador/visaogeral",
    "/administrador/estabelecimento-usuario",
    "/administrador/estabelecimento-documento",
    "/administrador/send_mail",
    "/administrador/email",
    "/administrador/cnpj",
    "/administrador/usuario",
    "/administrador/auditoria",
    "/attachment-units-by-center/",
    "/administrador/attachment/conference/",
    "/administrador/attachment/busca-geral/",
    "/administrador/liberar_acesso/",
    "/administrador/anexo/cadastrar/",
    "/administrador/cnpj/cadastrar",
    "/administrador/estabelecimento-documento/cadastrar",
    "/administrador/estabelecimento-usuario/cadastrar",
    "/administrador/usuario/1/editar/",
    "/administrador/cnpj/1/editar/",
    "/administrador/establishment/1/anexar/",
    "/administrador/estabelecimento-documento/1/editar/",
    "/administrador/documento/invalidacao/1/",
    "/administrador/documento/vencimento/1/",
    "/administrador/estabelecimento-usuario/1/editar/",
    "/administrador/estabelecimento/1/editar/",
    "/administrador/cnpj/1/excluir/",
    "/administrador/estabelecimento-usuario/1/excluir/",
    "/administrador/estabelecimento-documento/1/excluir/",
    "/administrador/attachment/REGIAO-X/CENTRO-Y/documentos/",
    "/administrador/attachment/DocumentoA/REGIAO-X/CENTRO-Y/busca-2-filtros/",
    "/administrador/home",
    "/administrador/attachment/validation/1/",
    "/api/health",
    "/api/_probe/jwt",
    "/api/_probe/upload",
    "/api/_probe/ssrf",
    "/download-pdf/1/",
    "/api/attachments/1/signed-links",
]

def _dedupe(seq):
    out, seen = [], set()
    for s in seq:
        if s not in seen:
            out.append(s)
            seen.add(s)
    return out

DEFAULT_ENDPOINTS = _dedupe(URLS_FROM_URLPATTERNS)
ENV_ENDPOINTS = [e if e.startswith("/") else f"/{e}" for e in os.getenv("PT_ENDPOINTS", "").split(",") if e.strip()]
TEST_ENDPOINTS = _dedupe(ENV_ENDPOINTS or DEFAULT_ENDPOINTS)

# Par√¢metros (mesmos do WAF) ‚Äî limpo (sem strings triplas/coment√°rios)
PARAM_NAMES = [
    p.strip() for p in os.getenv(
        "PT_PARAM_NAMES",
        (
            "name,d_doc,"
            "document,region,state,center,data_inserted,data_expire,situation,page,number_doc,file,"
            "cod,login,profile,action,object,description,"
            "rcd_fk_establishment,rcd_fk_document,"
            "user,"
            "ndest_fk_establishment,ndest_units,ndest_cnpj,ndest_nire,ndest_reg_state,ndest_reg_city,"
            "unit,cnpj,nire,reg_city,reg_state,"
            "att_data_expire,att_just,"
            "id,subject,email,data_shipping,pare,"
            "city,address,manage,property,"
            "est_manage,est_property,"
            "user_id,u_time_out,u_profile,u_status,"
            "login,time_in,time_out,status,"
            "q,search,term,redirect,returnTo,next,filter,sort,path"
        )
    ).split(",")
    if p.strip()
]

# Endpoints principais usados por este script (mantidos)
FORM_CREATE_ENDPOINT = os.getenv("PT_FORM_CREATE_ENDPOINT", "/administrador/documento/cadastrar").strip()
AJAX_LIST_ENDPOINT   = os.getenv("PT_AJAX_LIST_ENDPOINT",   "/administrador/documento").strip()
JSON_HEALTH_ENDPOINT = os.getenv("PT_JSON_PROBE_ENDPOINT",  "/api/health").strip()

# Credenciais (para login)
CREDENTIALS = {
    "login":    os.getenv("PT_LOGIN", "vlucas.silva"),
    "password": os.getenv("PT_PASSWORD", "admin123"),
}
LOGIN_FIELD_ENV    = os.getenv("PT_LOGIN_FIELD", "").strip() or None
PASSWORD_FIELD_ENV = os.getenv("PT_PASSWORD_FIELD", "").strip() or None

# Cookie de sess√£o pr√©-existente (opcional)
PRESET_SESSIONID = os.getenv("PT_SESSIONID", "").strip()

# =========================
# Sess√£o HTTP
# =========================

session = requests.Session()
if PRESET_SESSIONID:
    host = urlparse(BASE_URL).hostname or "localhost"
    session.cookies.set("sessionid", PRESET_SESSIONID, domain=host, path="/")

# =========================
# Helpers gerais
# =========================

def get_csrf_from_html(html_text: str):
    m = re.search(
        r'name=["\']csrfmiddlewaretoken["\']\s+value=["\']([^"\']+)["\']',
        html_text or "",
        re.IGNORECASE,
    )
    return m.group(1) if m else None

def get_first_form(html_text: str):
    # Mantido (n√£o √© usado no login agora, mas preservado para n√£o alterar estrutura)
    html = html_text or ""
    fm = re.search(r"<form[^>]*>(.*?)</form>", html, re.IGNORECASE | re.DOTALL)
    if not fm:
        return None, None, {}
    form_html = fm.group(0)
    body_html = fm.group(1)
    am = re.search(r"<form[^>]*\saction=[\"']([^\"']+)[\"']", form_html, re.IGNORECASE)
    action = am.group(1) if am else ""
    inputs = {}
    for m in re.finditer(r"<input[^>]*>", body_html, re.IGNORECASE):
        tag = m.group(0)
        name_m = re.search(r"\sname=[\"']([^\"']+)[\"']", tag, re.IGNORECASE)
        if not name_m:
            continue
        nm = name_m.group(1)
        type_m = re.search(r"\stype=[\"']([^\"']+)[\"']", tag, re.IGNORECASE)
        tp = (type_m.group(1).lower() if type_m else "text")
        val_m = re.search(r"\svalue=[\"']([^\"']*)[\"']", tag, re.IGNORECASE)
        val = val_m.group(1) if val_m else ""
        inputs[nm] = {"type": tp, "value": val}
    return form_html, action, inputs

_ALLOWED_HDR_CHARS = set(string.ascii_letters + string.digits + string.punctuation + " ")

def _safe_header_value(val: str) -> str:
    if not isinstance(val, str):
        val = str(val)
    val = re.sub(r"[\u0000-\u001F\u007F\u200B-\u200F\u202A-\u202E\u2060-\u206F\uFEFF\u00AD\u034F]", "", val)
    val = "".join(ch if ch in _ALLOWED_HDR_CHARS else "?" for ch in val)
    try:
        val.encode("latin-1", "strict")
    except UnicodeEncodeError:
        val = val.encode("latin-1", "ignore").decode("latin-1", "ignore")
    return val

def _sanitize_headers(h: dict | None) -> dict:
    if not h:
        return {}
    out = {}
    for k, v in h.items():
        kk = re.sub(r"[^A-Za-z0-9\-]", "-", str(k))
        out[kk] = _safe_header_value(v)
    return out

def try_get(url, headers=None, allow_redirects=False):
    try:
        return session.get(
            url,
            verify=VERIFY_TLS,
            timeout=TIMEOUT,
            headers=_sanitize_headers(headers),
            allow_redirects=allow_redirects,
        )
    except requests.RequestException as e:
        print(f"[x] ERRO GET {url}: {e}")
        return None

def try_post(url, data=None, headers=None, allow_redirects=False, files=None, json_body=None):
    try:
        if json_body is not None:
            return session.post(
                url,
                json=json_body,
                verify=VERIFY_TLS,
                timeout=TIMEOUT,
                headers=_sanitize_headers(headers),
                allow_redirects=allow_redirects,
            )
        return session.post(
            url,
            data=data or {},
            files=files or {},
            verify=VERIFY_TLS,
            timeout=TIMEOUT,
            headers=_sanitize_headers(headers),
            allow_redirects=allow_redirects,
        )
    except requests.RequestException as e:
        print(f"[x] ERRO POST {url}: {e}")
        return None

def is_blocked(resp):
    return resp is not None and resp.status_code in (403, 406, 415, 429)

def looks_unauthorized(resp):
    if resp is None:
        return False
    if resp.status_code in (301, 302, 303, 307, 308):
        loc = resp.headers.get("Location", "")
        return "login" in loc.lower()
    if resp.status_code == 200:
        txt = (resp.text or "").lower()
        hints = ('name="login"', 'type="password"', "csrfmiddlewaretoken", "entrar", "fazer login")
        return any(h in txt for h in hints)
    return False

def absolutize_action(form_action: str, default_url: str) -> str:
    if not form_action:
        return default_url
    if form_action.startswith("http://") or form_action.startswith("https://"):
        return form_action
    base = LOGIN_URL
    if form_action.startswith("/"):
        return urljoin(BASE_URL, form_action.lstrip("/"))
    return urljoin(base if base.endswith("/") else (base + "/"), form_action)

def norm_endpoint(ep: str) -> str:
    return ep if ep.startswith("/") else f"/{ep}"

# =========================
# Reporter
# =========================

class Reporter:
    def __init__(self):
        self.rows = []
        self.evidence = []
        self.counts = Counter()

    def _mkrow(self, label, method, resp, url, expected_block=False, note=None, latency=None):
        now = datetime.now(UTC).isoformat()
        if resp is None:
            outcome, code = "ERROR", 0
        elif is_blocked(resp):
            outcome = "BLOCKED/EXPECTED" if expected_block else "BLOCKED"
            code = resp.status_code
        elif looks_unauthorized(resp):
            outcome, code = "REDIR_LOGIN", resp.status_code
        else:
            if resp.status_code in (200, 201, 204, 302):
                outcome = "OK"
            else:
                outcome = "RESP"
            code = resp.status_code

        row = {
            "ts": now,
            "label": label,
            "method": method,
            "status_code": code,
            "outcome": outcome,
            "url": url,
            "latency_ms": int((latency or 0.0) * 1000),
            "note": note or "",
        }
        evh = {}
        if resp is not None:
            for k in ("Content-Type", "Location", "Set-Cookie", "X-Frame-Options",
                      "X-Content-Type-Options", "Content-Security-Policy", "Referrer-Policy"):
                if k in resp.headers:
                    evh[k] = resp.headers.get(k)
        self.evidence.append({**row, "headers": evh, "body_sample": (resp.text or "")[:600] if resp is not None else ""})
        self.rows.append(row)
        self.counts[(label, row["outcome"])] += 1

        lat = f" {row['latency_ms']}ms" if latency is not None else ""
        nn  = f" | {note}" if note else ""
        print(f"[{method}] {label:24} {row['outcome']:16} {code:3}{lat}  {url}{nn}")

    def write_reports(self):
        try:
            with open(OUTPUT_JSON, "w", encoding="utf-8") as f:
                json.dump({"rows": self.rows, "evidence": self.evidence}, f, ensure_ascii=False, indent=2)
            fields = ["ts","label","method","status_code","outcome","url","latency_ms","note"]
            with open(OUTPUT_CSV, "w", encoding="utf-8", newline="") as f:
                w = csv.DictWriter(f, fieldnames=fields)
                w.writeheader()
                for r in self.rows:
                    w.writerow({k: r.get(k, "") for k in fields})
            print(f"\n[‚úì] Exportado: {OUTPUT_JSON}, {OUTPUT_CSV}")
        except Exception as e:
            print(f"[x] Falha ao exportar: {e}")

# =========================
# Login ‚Äî MESMO do primeiro pentest (um POST com login/password)
# =========================

def login():
    print("[*] Abrindo /login para obter CSRF...")
    resp_get = session.get(LOGIN_URL, verify=VERIFY_TLS, timeout=TIMEOUT, allow_redirects=True)
    csrftoken = get_csrf_from_html(resp_get.text) if resp_get is not None else None
    if not csrftoken:
        csrftoken = session.cookies.get("app_csrf") or session.cookies.get("csrftoken")

    # Se cookie de sess√£o j√° veio pronto, tenta usar direto
    if PRESET_SESSIONID:
        print("[*] Usando sess√£o pr√©-existente (PT_SESSIONID). Validando acesso...")
        chk = session.get(BASE_URL, verify=VERIFY_TLS, timeout=TIMEOUT, allow_redirects=True)
        if chk is not None and not looks_unauthorized(chk):
            print("[+] Sess√£o aceita ‚Äî autenticado.")
            return True
        print("[!] Sess√£o n√£o aceita ‚Äî tentando login normal.")

    # Campos como no 1¬∫ pentest: usam as chaves do dict CREDENTIALS (padr√£o: login/password)
    user_field = LOGIN_FIELD_ENV or "login"
    pass_field = PASSWORD_FIELD_ENV or "password"

    payload = {
        user_field: CREDENTIALS["login"],
        pass_field: CREDENTIALS["password"],
    }
    if csrftoken:
        payload["csrfmiddlewaretoken"] = csrftoken

    print(f"[*] Enviando POST de login com campos: {user_field}/{pass_field} ...")
    resp = session.post(
        LOGIN_URL,
        data=payload,
        verify=VERIFY_TLS,
        timeout=TIMEOUT,
        allow_redirects=False,
        headers={"Referer": LOGIN_URL},
    )

    if resp is not None and resp.status_code in (302, 303) and "login" not in resp.headers.get("Location", "").lower():
        print("[+] Login ok (redirect p√≥s-login)")
        return True
    if resp is not None and resp.status_code == 200 and ("logout" in (resp.text or "").lower() or 'name="logout"' in (resp.text or "").lower()):
        print("[+] Login ok (200)")
        return True

    code = resp.status_code if resp is not None else "NA"
    print(f"[!] Falha no login (status {code}) ‚Äî verifique PT_LOGIN/PT_PASSWORD ou os nomes PT_LOGIN_FIELD/PT_PASSWORD_FIELD.")
    return False

# =========================
# Testes (originais mantidos)
# =========================

def timed_call(fn, *args, **kwargs):
    t0 = time.time()
    r  = fn(*args, **kwargs)
    dt = time.time() - t0
    return r, dt

def test_config_session_serializer(reporter: Reporter):
    reporter._mkrow(
        label="ConfigCheck:SessionSerializer",
        method="N/A",
        resp=None,
        url=BASE_URL,
        expected_block=False,
        note="N√£o observ√°vel via HTTP; verificar settings.py (SESSION_SERIALIZER=JSONSerializer)",
    )

def test_csrf_no_token(reporter: Reporter):
    url = urljoin(BASE_URL, FORM_CREATE_ENDPOINT.lstrip("/"))
    r, dt = timed_call(try_post, url, data={"teste": "valor"}, headers={"Content-Type":"application/x-www-form-urlencoded"})
    reporter._mkrow("CSRF (no token)", "POST", r, url, expected_block=True)

def test_content_type_enforcement(reporter: Reporter):
    url_form = urljoin(BASE_URL, FORM_CREATE_ENDPOINT.lstrip("/"))
    bad_cts  = [
        ("application/json", json.dumps({"d_doc": "ABC"})),
        ("application/xml",  "<doc>ABC</doc>"),
        ("application/x-yaml",  "a: !!python/object/apply:os.system ['id']"),
        ("application/octet-stream", b"\x80\x04K*."),  # pickle-like bin√°rio
        ("text/plain",       "d_doc=ABC"),
    ]
    for ctype, body in bad_cts:
        headers = {"Content-Type": ctype}
        if isinstance(body, (bytes, bytearray)):
            resp = session.post(url_form, data=body, verify=VERIFY_TLS, timeout=TIMEOUT,
                                headers=_sanitize_headers(headers), allow_redirects=False)
            r, dt = resp, 0.0
        elif isinstance(body, str) and ctype != "application/json":
            r, dt = timed_call(try_post, url_form, data=body, headers=headers, allow_redirects=False)
        else:
            r, dt = timed_call(try_post, url_form, json_body=(json.loads(body) if ctype=="application/json" else None),
                               headers=headers, allow_redirects=False)
        reporter._mkrow("CT-Enforce", "POST", r, url_form, expected_block=True)

    url_json = urljoin(BASE_URL, JSON_HEALTH_ENDPOINT.lstrip("/"))
    r2, dt2 = timed_call(try_post, url_json, data={"ok":"1"}, headers={"Content-Type":"application/x-www-form-urlencoded"})
    reporter._mkrow("CT-Enforce", "POST", r2, url_json, expected_block=True)

def test_ajax_json(reporter: Reporter):
    url = urljoin(BASE_URL, AJAX_LIST_ENDPOINT.lstrip("/"))
    r, dt = timed_call(try_get, url, headers={"X-Requested-With":"XMLHttpRequest"})
    note = ""
    expected = looks_unauthorized(r) or (r is not None and r.status_code == 403)
    if r is not None and r.status_code == 200:
        ct = r.headers.get("Content-Type","")
        if "application/json" not in ct.lower():
            note = "Content-Type inesperado"
    reporter._mkrow("AJAX-List(JSON)", "GET", r, url, expected_block=expected, note=note)

def test_pickle_smuggling(reporter: Reporter):
    form_url = urljoin(BASE_URL, FORM_CREATE_ENDPOINT.lstrip("/"))
    g = try_get(form_url, allow_redirects=True)
    token = get_csrf_from_html(g.text) if g is not None else None
    payload = base64.b64encode(b"\x80\x04K\x2e.").decode()  # lixo "pickle-like"

    data = {"d_doc": f"ZZZ {payload}"}
    if token:
        data["csrfmiddlewaretoken"] = token
    r, dt = timed_call(try_post, form_url, data=data,
                       headers={"Content-Type":"application/x-www-form-urlencoded", "Referer": form_url},
                       allow_redirects=False)
    expected = looks_unauthorized(r) or (r is not None and r.status_code == 403)
    reporter._mkrow("PickleSmuggling", "POST", r, form_url, expected_block=expected,
                    note="Esperado: erro de valida√ß√£o/200/302; sem desserializar nada.")

def test_json_guard(reporter: Reporter):
    url = urljoin(BASE_URL, JSON_HEALTH_ENDPOINT.lstrip("/"))
    huge = {"x": "A" * 300000}  # 300 KB
    deep = nested = {"d": "x"}
    for _ in range(70):
        nested = {"d": nested}
    many = {f"k{i}": i for i in range(20000)}
    alphabet = string.ascii_letters + string.digits + "+/="
    high_entropy = {"h": "".join(random.choice(alphabet) for _ in range(120000))}

    for label, body in [
        ("JSON-Guard (huge)", huge),
        ("JSON-Guard (deep)", deep),
        ("JSON-Guard (many-keys)", many),
        ("JSON-Guard (entropy)", high_entropy),
    ]:
        r, dt = timed_call(try_post, url, json_body=body, headers={"Content-Type":"application/json"}, allow_redirects=False)
        reporter._mkrow(label, "POST", r, url, expected_block=True, latency=dt)

def test_cookies_headers(reporter: Reporter):
    r, dt = timed_call(try_get, BASE_URL, allow_redirects=True)
    note = "ok"
    reporter._mkrow("Cookies/Headers", "GET", r, BASE_URL, expected_block=False, note=note)

# =========================
# NOVOS TESTES (URLs + par√¢metros do WAF)
# =========================

INVISIBLE_CHARS = "\u200B\u200C\u200D\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206C\u206D\u206E\u206F\uFEFF\u00AD\u034F"

def test_param_sweep_get_post(reporter: Reporter, max_params_each=6):
    """
    Varredura leve: para cada endpoint, faz:
      - GET com alguns PARAM_NAMES (=payload benigno e com invis√≠veis)
      - POST form com PARAM_NAMES aleat√≥rio (=payload benigno e ‚Äúpickle-like‚Äù)
    N√£o substitui testes originais; apenas amplia cobertura de desserializa√ß√£o/normaliza√ß√£o.
    """
    benign = "teste-param"
    weird  = "alert(1)" + INVISIBLE_CHARS
    pickle_like = base64.b64encode(b"\x80\x04K*evil.").decode()

    for ep in TEST_ENDPOINTS:
        base = urljoin(BASE_URL, norm_endpoint(ep))

        # GET ‚Üí benigno e invis√≠vel (at√© max_params_each por endpoint)
        for p in PARAM_NAMES[:max_params_each]:
            url_benign = f"{base}?{quote(p)}={quote(benign)}"
            r1, d1 = timed_call(try_get, url_benign, allow_redirects=False)
            reporter._mkrow("ParamSweep:GET:benign", "GET", r1, url_benign,
                            expected_block=looks_unauthorized(r1) or (r1 is not None and r1.status_code in (403,406)))

            url_weird = f"{base}?{quote(p)}={quote(weird)}"
            r2, d2 = timed_call(try_get, url_weird, allow_redirects=False)
            reporter._mkrow("ParamSweep:GET:invisible", "GET", r2, url_weird,
                            expected_block=looks_unauthorized(r2) or (r2 is not None and r2.status_code in (403,406)))

        # POST form ‚Üí um par√¢metro aleat√≥rio com payload pickle-like
        if PARAM_NAMES:
            p = random.choice(PARAM_NAMES)
            data = {p: f"XX {pickle_like}"}
            r3, d3 = timed_call(try_post, base, data=data,
                                headers={"Content-Type":"application/x-www-form-urlencoded"},
                                allow_redirects=False)
            reporter._mkrow("ParamSweep:POST:pickle-like", "POST", r3, base,
                            expected_block=looks_unauthorized(r3) or (r3 is not None and r3.status_code in (403,406,415)))

def test_json_param_injection(reporter: Reporter, max_params_each=6):
    """
    Envia JSON para o endpoint JSON previsto e tamb√©m para alguns endpoints regulares,
    usando chaves equivalentes a PARAM_NAMES (varredura de chaves).
    """
    # 1) Endpoint JSON oficial
    url_json = urljoin(BASE_URL, JSON_HEALTH_ENDPOINT.lstrip("/"))
    body = {k: f"v{k[:2]}" for k in PARAM_NAMES[:max_params_each]}
    r, dt = timed_call(try_post, url_json, json_body=body, headers={"Content-Type":"application/json"}, allow_redirects=False)
    reporter._mkrow("JSON-Param:health", "POST", r, url_json, expected_block=False)

    # 2) Enviar JSON (indevido) em alguns endpoints normais ‚Äî deve bloquear (415/403)
    for ep in TEST_ENDPOINTS[:10]:
        base = urljoin(BASE_URL, norm_endpoint(ep))
        body2 = {k: f"x{k[:1]}" for k in PARAM_NAMES[:max_params_each]}
        r2, d2 = timed_call(try_post, base, json_body=body2, headers={"Content-Type":"application/json"}, allow_redirects=False)
        reporter._mkrow("JSON-Param:strict", "POST", r2, base, expected_block=True)

def test_form_realistic_d_doc(reporter: Reporter):
    """
    POST realista no form de cria√ß√£o de Documento (usa d_doc + CSRF).
    Tenta benigno e tenta valor com invis√≠veis.
    """
    form_url = urljoin(BASE_URL, FORM_CREATE_ENDPOINT.lstrip("/"))
    g = try_get(form_url, allow_redirects=True)
    token = get_csrf_from_html(g.text) if g is not None else None

    def do_post(value, label):
        data = {"d_doc": value}
        if token:
            data["csrfmiddlewaretoken"] = token
        r, dt = timed_call(
            try_post,
            form_url,
            data=data,
            headers={"Content-Type":"application/x-www-form-urlencoded", "Referer": form_url},
            allow_redirects=False
        )
        expected = looks_unauthorized(r) or (r is not None and r.status_code == 403)
        reporter._mkrow(label, "POST", r, form_url, expected_block=expected)

    do_post("Comprovante de Endereco", "Form:d_doc:benign")
    do_post("XX" + INVISIBLE_CHARS + "YY", "Form:d_doc:invisible")

# =========================
# Execu√ß√£o principal
# =========================

def main():
    print("[üöÄ] Pentest ‚Äî Desserializa√ß√£o & Adjacent (standalone++)")
    ok = login()
    if not ok:
        print("[!] Login n√£o confirmado. Algumas rotas admin podem retornar 403/redirect ‚Äî tratado como esperado.")

    rep = Reporter()
    try:
        # Originais (mantidos)
        test_config_session_serializer(rep)
        test_csrf_no_token(rep)
        test_content_type_enforcement(rep)
        test_ajax_json(rep)
        test_pickle_smuggling(rep)
        test_json_guard(rep)
        test_cookies_headers(rep)

        # Acrescidos (URLs/parametros iguais ao WAF)
        test_param_sweep_get_post(rep, max_params_each=6)
        test_json_param_injection(rep, max_params_each=6)
        test_form_realistic_d_doc(rep)

    finally:
        rep.write_reports()
        print("[‚úÖ] Finalizado.")

if __name__ == "__main__":
    main()
