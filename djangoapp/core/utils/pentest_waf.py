#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Pentest WAF ‚Äî su√≠te avan√ßada (completa ++, vers√£o consolidada)
Inclui melhorias de or√°culos por categoria, baseline de lat√™ncia,
e cobertura ampliada de endpoints baseada no urlpatterns fornecido.

‚ö†Ô∏è Altera√ß√µes nesta vers√£o:
- Saneamento de headers para evitar UnicodeEncodeError (latin-1) quando
  os payloads cont√™m caracteres invis√≠veis/Unicode.
- enumerate_targets mant√©m teste via header X-Probe, agora com saneamento.
"""

import os
import re
import sys
import time
import hmac
import json
import csv
import uuid
import base64
import hashlib
import random
import string
import statistics
import requests
from urllib.parse import quote, urljoin, urlparse
from datetime import datetime, timedelta
from collections import defaultdict, Counter
from concurrent.futures import ThreadPoolExecutor, as_completed

# =========================
# Config
# =========================

BASE_URL   = os.getenv("PT_BASE_URL", "http://localhost:8000/")
LOGIN_URL  = urljoin(BASE_URL, os.getenv("PT_LOGIN_URL", "login"))
VERIFY_TLS = os.getenv("PT_VERIFY_TLS", "false").lower() in ("1","true","yes")
TIMEOUT    = int(os.getenv("PT_TIMEOUT", "15"))
SLEEP_BETWEEN = float(os.getenv("PT_SLEEP", "0.08"))
SAFE_MODE  = os.getenv("PT_SAFE_MODE", "true").lower() in ("1","true","yes")

# Relat√≥rios
OUTPUT_JSON = os.getenv("PT_OUTPUT_JSON", "pentest_results.json")
OUTPUT_CSV  = os.getenv("PT_OUTPUT_CSV",  "pentest_results.csv")
EVIDENCE_SAMPLE_LIMIT = int(os.getenv("PT_EVIDENCE_LIMIT", "80"))

# Par√¢metros adicionais
OPENREDIR_PARAMS = [p.strip() for p in os.getenv("PT_OPENREDIR_PARAMS", "next,redirect,returnTo").split(",") if p.strip()]
CORS_TEST_ORIGINS = [o.strip() for o in os.getenv("PT_CORS_TEST_ORIGINS", "").split(",") if o.strip()]
JSON_PROBE_ENDPOINTS = [e if e.startswith("/") else f"/{e}" for e in os.getenv("PT_JSON_PROBE_ENDPOINTS", "/api/health").split(",") if e.strip()]
FORM_PROBE_ENDPOINTS = [e if e.startswith("/") else f"/{e}" for e in os.getenv("PT_FORM_PROBE_ENDPOINTS", "/login").split(",") if e.strip()]
UPLOAD_ENDPOINT = os.getenv("PT_UPLOAD_ENDPOINT", "/api/_probe/upload").strip()
SSRF_ENDPOINTS  = [e if e.startswith("/") else f"/{e}" for e in os.getenv("PT_SSRF_ENDPOINTS", "/api/_probe/ssrf").split(",") if e.strip()]
JWT_PROBE_ENDPOINT = os.getenv("PT_JWT_PROBE_ENDPOINT", "/api/_probe/jwt").strip()
JWT_BEARER_VALID = os.getenv("PT_JWT_BEARER_VALID", "").strip()

CREDENTIALS = {
    "login":    os.getenv("PT_LOGIN", "vlucas.silva"),
    "password": os.getenv("PT_PASSWORD", "admin123"),
}

TEST_SECRET_KEY           = os.getenv("PT_SECRET_KEY", "xKj5uB2LZ=V5c8H?%qYJ{<;ZAwFt+&R3M@E0hGOp")
SIGNED_URL_TTL_SECONDS    = int(os.getenv("PT_PDF_TTL", "60"))
TEST_USER_ID              = int(os.getenv("PT_USER_ID", "1"))
TEST_ATTACHMENT_ID        = int(os.getenv("PT_ATTACHMENT_ID", "1"))

DOS_RATE_BURST            = int(os.getenv("PT_DOS_RATE_BURST", "120" if SAFE_MODE else "320"))
DOS_BURST_ENDPOINT        = os.getenv("PT_DOS_BURST_ENDPOINT", "/administrador/home")
DOS_LARGE_VALUE_LEN       = int(os.getenv("PT_DOS_LARGE_VALUE_LEN", "50000" if SAFE_MODE else "120000"))
DOS_HIGH_ENTROPY_LEN      = int(os.getenv("PT_DOS_HIGH_ENTROPY_LEN", "80000" if SAFE_MODE else "200000"))

# =========================
# Endpoints (AMPLIADO DO urlpatterns FORNECIDO)
# =========================

URLS_FROM_URLPATTERNS = [
    "/administrador/documento",
    "/administrador/documento/cadastrar",
    "/administrador/documento/1/excluir/",
    "/administrador/documento/1/editar/",

    "/api/health",
    "/api/_probe/jwt",
    "/api/_probe/upload",
    "/api/_probe/ssrf",
    "/download-pdf/1/",
    "/api/attachments/1/signed-links",
]

def _dedupe(seq):
    out, seen = [], set()
    for s in seq:
        if s not in seen:
            out.append(s)
            seen.add(s)
    return out

DEFAULT_ENDPOINTS = _dedupe(URLS_FROM_URLPATTERNS)

# Permitindo sobreposi√ß√£o via vari√°vel de ambiente
ENV_ENDPOINTS = [e if e.startswith("/") else f"/{e}" for e in os.getenv("PT_ENDPOINTS", "").split(",") if e.strip()]
TEST_ENDPOINTS = _dedupe(ENV_ENDPOINTS or DEFAULT_ENDPOINTS)

# Chaves sens√≠veis
SENSITIVE_ID_KEYS = [
    "u_id","user_id","est_id","d_id","estaux_id","ndest_id",
    "establishment_id","document_id","attachment_id","rcu_id","att_id","rcd_id","aud_id","em_id","id","sec_id"
]

# Nomes comuns de par√¢metros
PARAM_NAMES = [
    p.strip()
    for p in os.getenv(
        "PT_PARAM_NAMES",
        (
            # Documentos (listagem AJAX)
            "name, d_doc"

            # Gen√©ricos/seguran√ßa
            "q,search,term,redirect,returnTo,next,filter,sort,path"
        )
    ).split(",")
    if p.strip()
]
INVISIBLE_CHARS = "\u200B\u200C\u200D\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206C\u206D\u206E\u206F\uFEFF\u00AD\u034F"

PAYLOADS = {
    "SQL Injection": [
        "' OR '1'='1",
        "' UNION SELECT null--",
        "1; DROP TABLE users--",
        "UNION select password from users",
        "sleep(5)",
        "AND 1=1; SELECT @@version; --",
        "1' OR SLEEP(3)-- -",
    ],
    "XSS": [
        "<script>alert(1)</script>",
        '"><svg/onload=alert(1)>',
        "%3Cimg%20src%3Dx%20onerror%3Dalert(1)%3E",
        "javascript:alert(1)",
        "<IMG SRC=x onerror=alert(1)>",
        "document.cookie",
        "\" onfocus=alert(1) autofocus=\"",
    ],
    "DOM XSS": [
        '"><img src=x onerror="document.write(\'<svg onload=alert(1)>\')">',
        "setTimeout('alert(1)')",
        "eval('alert(1)')",
        "Function('alert(1)')()",
        "location.hash='#<img src=x onerror=alert(1)>'",
        'srcdoc="<svg onload=alert(1)>"',
        "innerHTML=<svg onload=alert(1)>",
    ],
    "Template/Code Injection": [
        "{{ __import__('os').system('id') }}",
        "{{ config.items() }}",
        "{{ request.application.__globals__ }}",
        "{% include '/etc/passwd' %}",
    ],
    "Path Traversal": [
        "../../etc/passwd",
        "..%2F..%2Fwindows%2Fwin.ini",
        "/etc/passwd",
        "%2e%2e/%2e%2e/%2e%2e/secret",
    ],
    "Command Injection": [
        ";cat /etc/passwd",
        "|whoami",
        "&&id",
        "uname -a | id",
        "&& powershell -nop -c whoami",
    ],
    "SSRF": [
        "http://127.0.0.1:80",
        "http://127.0.0.1:8080/admin",
        "http://169.254.169.254/latest/meta-data/",
        "http://10.0.0.1",
        "file:///etc/passwd",
        "gopher://127.0.0.1:70/_hi",
        "http://2130706433",
        "http://[::1]/",
        "http://localhost/",
    ],
    "Encoding/Invisible": [
        "alert(1)" + INVISIBLE_CHARS,
        "a%00b%00c",
        "%FF%FE%41",
        "A" + "\u202E" + "B",
    ],
    "Headers/Weird": [
        "   OR   1 = 1   ",
        "Ôº°Ôº¢Ôº£ÔºëÔºíÔºì",
    ],
    "Benign OR/AND (n√£o cr√≠tico)": ["or", "and", "like", "in"],
    "XXE (texto)": [
        """<?xml version="1.0"?><!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>"""
    ],
    "QS Raw (pr√©-decode)": [
        "%25%33%43script%25%33%45", 
        "%00",                       
        "%ef%bc%a1",                
        "or%20%31%3d%31",            
    ],
}

OPENREDIR_VALUES = [
    "/admin", "//evil.example", "https://evil.example/",
    "%2f%2fevil.example", r"\\evil.example", "///evil.example",
    "/////evil.example", "/%2e%2e//evil.example", "http:/\\evil.example",
    "https:%2f%2fevil.example", "http:%2f%2fevil.example", "//%2Fevil.example"
]

# =========================
# Sess√£o HTTP
# =========================
session = requests.Session()

def _hmac(value: str) -> str:
    return hmac.new(TEST_SECRET_KEY.encode(), value.encode(), hashlib.sha256).hexdigest()

def build_signed_pdf_params(attachment_id: int, user_id: int, ttl_seconds: int = None):
    ttl = int(ttl_seconds or SIGNED_URL_TTL_SECONDS)
    exp = int((datetime.utcnow() + timedelta(seconds=ttl)).timestamp())
    sig = _hmac(f"{attachment_id}|{user_id}|{exp}")
    return {"exp": str(exp), "sig": sig, "user_id": str(user_id)}

def signed_pdf_url(attachment_id: int, user_id: int):
    params = build_signed_pdf_params(attachment_id, user_id)
    path = f"download-pdf/{attachment_id}/"
    qs = f"?exp={params['exp']}&sig={params['sig']}&user_id={params['user_id']}"
    return urljoin(BASE_URL, path) + qs

def get_csrf_from_html(html_text: str):
    m = re.search(r'name=["\']csrfmiddlewaretoken["\']\s+value=["\']([^"\']+)["\']', html_text or "", re.IGNORECASE)
    return m.group(1) if m else None

def login():
    print("[*] Abrindo /login para obter CSRF...")
    resp_get = session.get(LOGIN_URL, verify=VERIFY_TLS, timeout=TIMEOUT, allow_redirects=True)
    csrftoken = get_csrf_from_html(resp_get.text) if resp_get is not None else None
    if not csrftoken:
        csrftoken = session.cookies.get("app_csrf") or session.cookies.get("csrftoken")

    payload = dict(CREDENTIALS)
    if csrftoken:
        payload["csrfmiddlewaretoken"] = csrftoken

    print("[*] Enviando POST de login...")
    resp = session.post(LOGIN_URL, data=payload, verify=VERIFY_TLS, timeout=TIMEOUT,
                        allow_redirects=False, headers={"Referer": LOGIN_URL})
    if resp is not None and resp.status_code in (302, 303) and "login" not in resp.headers.get("Location", "").lower():
        print("[+] Login ok (redirect p√≥s-login)")
        return True
    if resp is not None and resp.status_code == 200 and ("logout" in (resp.text or "").lower() or 'name="logout"' in (resp.text or "").lower()):
        print("[+] Login ok (200)")
        return True

    code = resp.status_code if resp is not None else "NA"
    print(f"[!] Falha no login (status {code})")
    return False

# =========================
# Helpers de request/resultado (ALTERADOS p/ headers seguros)
# =========================

_ALLOWED_HDR_CHARS = set(string.ascii_letters + string.digits + string.punctuation + " ")

def _safe_header_value(val: str) -> str:
    if not isinstance(val, str):
        val = str(val)
    # remove invis√≠veis/control/bidi
    val = re.sub(r"[\u0000-\u001F\u007F\u200B-\u200F\u202A-\u202E\u2060-\u206F\uFEFF\u00AD\u034F]", "", val)
    # troca qualquer char fora do permitido por '?'
    val = "".join(ch if ch in _ALLOWED_HDR_CHARS else "?" for ch in val)
    # garante latin-1 (requests/urllib3 exigem)
    try:
        val.encode("latin-1", "strict")
    except UnicodeEncodeError:
        val = val.encode("latin-1", "ignore").decode("latin-1", "ignore")
    return val

def _sanitize_headers(h: dict | None) -> dict:
    if not h:
        return {}
    out = {}
    for k, v in h.items():
        # nomes de header: apenas token HTTP v√°lido
        kk = re.sub(r"[^A-Za-z0-9\-]", "-", str(k))
        out[kk] = _safe_header_value(v)
    return out

def is_blocked(resp):
    return resp is not None and resp.status_code in (403, 406, 429)

def looks_unauthorized(resp):
    if resp is None:
        return False
    if resp.status_code in (301, 302, 303, 307, 308):
        loc = resp.headers.get("Location", "")
        return "login" in loc.lower()
    if resp.status_code == 200:
        txt = (resp.text or "").lower()
        hints = ('name="login"', 'type="password"', "entrar", "fazer login", "csrfmiddlewaretoken")
        return any(h in txt for h in hints)
    return False

def try_get(url, headers=None, allow_redirects=False):
    try:
        return session.get(
            url,
            verify=VERIFY_TLS,
            timeout=TIMEOUT,
            headers=_sanitize_headers(headers),
            allow_redirects=allow_redirects
        )
    except requests.RequestException as e:
        print(f"[x] ERRO GET {url}: {e}")
        return None

def try_post(url, data=None, headers=None, allow_redirects=False, files=None, json_body=None):
    try:
        if json_body is not None:
            return session.post(
                url,
                json=json_body,
                verify=VERIFY_TLS,
                timeout=TIMEOUT,
                headers=_sanitize_headers(headers),
                allow_redirects=allow_redirects
            )
        return session.post(
            url,
            data=data or {},
            files=files or {},
            verify=VERIFY_TLS,
            timeout=TIMEOUT,
            headers=_sanitize_headers(headers),
            allow_redirects=allow_redirects
        )
    except requests.RequestException as e:
        print(f"[x] ERRO POST {url}: {e}")
        return None

def try_options(url, headers=None, allow_redirects=False):
    try:
        return session.options(
            url,
            verify=VERIFY_TLS,
            timeout=TIMEOUT,
            headers=_sanitize_headers(headers),
            allow_redirects=allow_redirects
        )
    except requests.RequestException as e:
        print(f"[x] ERRO OPTIONS {url}: {e}")
        return None

def norm_endpoint(ep: str) -> str:
    return ep if ep.startswith("/") else f"/{ep}"

def _origin_default():
    return CORS_TEST_ORIGINS or ["https://not-allowed.example", BASE_URL.rstrip("/")]

def jitter_sleep():
    time.sleep(SLEEP_BETWEEN + random.uniform(0.0, 0.05))

def body_sig(resp):
    if resp is None:
        return "NA"
    try:
        return hashlib.sha256((resp.text or "").encode("utf-8", "ignore")).hexdigest()
    except Exception:
        return "NA"

# =========================
# Reporter
# =========================
class Reporter:
    def __init__(self):
        self.rows = []
        self.counts = Counter()
        self.lat_by_cat = defaultdict(list)
        self.evidence = []
        self.evidence_left = EVIDENCE_SAMPLE_LIMIT

    def _mkrow(self, category, subcategory, mode, method, resp, url, latency=None, note=None):
        if resp is None:
            outcome, code, headers, body_sample = "ERROR", 0, {}, ""
        elif is_blocked(resp):
            outcome, code, headers, body_sample = "BLOCKED", resp.status_code, dict(resp.headers), (resp.text or "")[:800]
        elif looks_unauthorized(resp):
            outcome, code, headers, body_sample = "REDIR_LOGIN", resp.status_code, dict(resp.headers), (resp.text or "")[:800]
        else:
            if resp.status_code in (200, 302, 204, 405):
                outcome = "OK/PASS-or-NEUTRAL"
            else:
                outcome = "RESP"
            code, headers, body_sample = resp.status_code, dict(resp.headers), (resp.text or "")[:800]
        row = {
            "ts": datetime.utcnow().isoformat() + "Z",
            "category": category,
            "subcategory": subcategory or "",
            "mode": mode,
            "method": method,
            "status_code": code,
            "outcome": outcome,
            "url": url,
            "latency_ms": int((latency or 0.0)*1000),
            "note": note or "",
        }
        if self.evidence_left > 0:
            self.evidence_left -= 1
            ev_headers = {k: headers.get(k) for k in ("Content-Type","Content-Length","Location","Set-Cookie","Vary","Cache-Control","Content-Security-Policy","X-Frame-Options","X-Content-Type-Options","Strict-Transport-Security","Referrer-Policy","Permissions-Policy")}
            self.evidence.append({**row, "headers": ev_headers, "body_sample": body_sample})
        return row, row["outcome"], row["status_code"]

    def log(self, category: str, mode: str, method: str, resp, url: str, latency=None, note=None, subcategory=None):
        row, outcome, code = self._mkrow(category, subcategory, mode, method, resp, url, latency, note)
        self.rows.append(row)
        self.counts[(category, outcome)] += 1
        if latency is not None:
            self.lat_by_cat[category].append(latency)
        tag = f"[{method}/{mode}] {category:22} {outcome:18} {code:3}"
        if latency is not None:
            tag += f"  {int(latency*1000)}ms"
        if note:
            tag += f"  | {note}"
        print(f"{tag}  {url}")

    def summary(self):
        print("\n" + "="*100)
        print("RESUMO POR CATEGORIA")
        print("-"*100)
        outcomes = ["BLOCKED", "REDIR_LOGIN", "OK/PASS-or-NEUTRAL", "RESP", "ERROR"]
        cats = sorted(set([k[0] for k in self.counts.keys()]))
        header = "Categoria".ljust(26) + " ".join(o.ljust(20) for o in outcomes) + " p95(ms)".rjust(10) + " p99(ms)".rjust(10)
        print(header)
        print("-"*100)
        for cat in cats:
            line = cat.ljust(26)
            for o in outcomes:
                line += str(self.counts.get((cat, o), 0)).ljust(20)
            if self.lat_by_cat.get(cat):
                q = statistics.quantiles(self.lat_by_cat[cat], n=100)
                p95 = int(q[94]*1000) if len(q) >= 95 else int(statistics.mean(self.lat_by_cat[cat])*1000)
                p99 = int(q[98]*1000) if len(q) >= 99 else p95
                line += str(p95).rjust(10) + str(p99).rjust(10)
            else:
                line += " ".rjust(10) + " ".rjust(10)
            print(line)
        print("-"*100)
        total = sum(self.counts.values())
        blocked = sum(c for (cat, o), c in self.counts.items() if o == "BLOCKED")
        print(f"Total testes: {total} | BLOQUEADOS: {blocked} | Taxa de bloqueio: {blocked/(total or 1):.1%}")
        print("="*100 + "\n")
        try:
            with open(OUTPUT_JSON, "w", encoding="utf-8") as f:
                json.dump({"rows": self.rows, "evidence": self.evidence}, f, ensure_ascii=False, indent=2)
            with open(OUTPUT_CSV, "w", encoding="utf-8", newline="") as f:
                w = csv.DictWriter(f, fieldnames=list(self.rows[0].keys()) if self.rows else ["ts","category","subcategory","mode","method","status_code","outcome","url","latency_ms","note"])
                w.writeheader()
                for r in self.rows:
                    w.writerow(r)
            print(f"[‚úì] Exportado: {OUTPUT_JSON}, {OUTPUT_CSV}")
        except Exception as e:
            print(f"[x] Falha ao exportar: {e}")

# =========================
# Utilidades de teste base
# =========================
def enumerate_targets(payload, endpoints=None):
    endpoints = endpoints or TEST_ENDPOINTS
    for ep in endpoints:
        for p in PARAM_NAMES:
            url = urljoin(BASE_URL, f"{norm_endpoint(ep)}?{p}={quote(payload, safe='/:')}")
            yield ("GET", url, None, None)

    for ep in endpoints:
        data = {random.choice(PARAM_NAMES): payload}
        url = urljoin(BASE_URL, norm_endpoint(ep))
        yield ("POST", url, data, None)

    for ep in JSON_PROBE_ENDPOINTS:
        url = urljoin(BASE_URL, norm_endpoint(ep))
        yield ("POSTJSON", url, {"probe": payload}, None)

    hdr = {"X-Probe": payload}
    for ep in endpoints[:8]:
        url = urljoin(BASE_URL, norm_endpoint(ep))
        yield ("GET-HDR", url, None, hdr)

def timed_call(method, url, data=None, json_body=None, headers=None, allow_redirects=False):
    t0 = time.time()
    if method == "GET":
        r = try_get(url, headers=headers, allow_redirects=allow_redirects)
    elif method == "POST":
        r = try_post(url, data=data, headers=headers, allow_redirects=allow_redirects)
    elif method == "POSTJSON":
        r = try_post(url, json_body=json_body, headers=headers, allow_redirects=allow_redirects)
    elif method == "GET-HDR":
        r = try_get(url, headers=headers, allow_redirects=allow_redirects)
    elif method == "OPTIONS":
        r = try_options(url, headers=headers, allow_redirects=allow_redirects)
    else:
        r = None
    dt = time.time() - t0
    return r, dt

# =========================
# Testes originais (mantidos)
# =========================
def test_payload_matrix_enhanced(reporter: Reporter):
    print("\n[*] Testando payloads (Query/Form/JSON/Headers)")
    for attack_type, payload_list in PAYLOADS.items():
        for payload in payload_list:
            for method, url, data, headers in enumerate_targets(payload):
                if method == "POSTJSON":
                    r, dt = timed_call(method, url, json_body=data, headers=headers)
                    reporter.log(attack_type, "MIX", method, r, url, dt)
                elif method == "POST":
                    r, dt = timed_call(method, url, data=data, headers=headers)
                    reporter.log(attack_type, "MIX", method, r, url, dt)
                else:
                    r, dt = timed_call(method, url, headers=headers)
                    reporter.log(attack_type, "MIX", method, r, url, dt)
                jitter_sleep()

def test_qs_raw_guard(reporter: Reporter):
    print("\n[*] Testando QS Raw (pr√©-decode)")
    for payload in PAYLOADS["QS Raw (pr√©-decode)"]:
        for endpoint in TEST_ENDPOINTS:
            url = urljoin(BASE_URL, f"{norm_endpoint(endpoint)}?q={payload}")
            r, dt = timed_call("GET", url)
            reporter.log("QS Raw", "GET", "GET", r, url, dt)
            jitter_sleep()

def test_csrf(reporter: Reporter):
    print("\n[*] Testando POST sem CSRF (deve falhar)")
    for endpoint in TEST_ENDPOINTS:
        url = urljoin(BASE_URL, norm_endpoint(endpoint))
        r, dt = timed_call("POST", url, data={"teste": "valor"})
        reporter.log("CSRF (no token)", "POST", "POST", r, url, dt)
        jitter_sleep()

    print("\n[*] Testando POST com CSRF (deve passar s√≥ se a view aceitar POST)")
    home = session.get(BASE_URL, verify=VERIFY_TLS, timeout=TIMEOUT, allow_redirects=True)
    csrftoken = session.cookies.get("app_csrf") or session.cookies.get("csrftoken") or get_csrf_from_html(home.text if home is not None else "")
    for endpoint in TEST_ENDPOINTS:
        url = urljoin(BASE_URL, norm_endpoint(endpoint))
        data = {"csrfmiddlewaretoken": csrftoken or "", "teste": "valor"}
        r, dt = timed_call("POST", url, data=data)
        reporter.log("CSRF (with token)", "POST", "POST", r, url, dt)
        jitter_sleep()

def test_signed_pdf(reporter: Reporter):
    print("\n[*] Testando PDF assinado (fluxo positivo)")
    url = signed_pdf_url(TEST_ATTACHMENT_ID, TEST_USER_ID)
    r, dt = timed_call("GET", url, allow_redirects=True)
    reporter.log("Signed PDF", "GET", "GET", r, url, dt)

def rand_high_entropy(n: int) -> str:
    alphabet = string.ascii_letters + string.digits + "+/="
    return "".join(random.choice(alphabet) for _ in range(n))

def test_dos(reporter: Reporter):

    print("\n[*] DoS: payload gigante")
    big_payload = "A" * DOS_LARGE_VALUE_LEN
    ep = urljoin(BASE_URL, norm_endpoint(TEST_ENDPOINTS[0]))
    url = f"{ep}?q={quote(big_payload)}"
    r, dt = timed_call("GET", url)
    reporter.log("DoS:LargeValue", "GET", "GET", r, url, dt)


    print("[*] DoS: alta entropia")
    he = rand_high_entropy(DOS_HIGH_ENTROPY_LEN)
    url = f"{ep}?q={quote(he[:2048])}"
    r, dt = timed_call("GET", url)
    reporter.log("DoS:HighEntropy", "GET", "GET", r, url, dt)


    print("[*] DoS: rate limit (rajada)")
    burst_ep = urljoin(BASE_URL, norm_endpoint(DOS_BURST_ENDPOINT))
    blocked = 0
    total = 0
    start = time.time()
    for _ in range(DOS_RATE_BURST):
        rr = try_get(burst_ep)
        total += 1
        if is_blocked(rr) and rr.status_code == 429:
            blocked += 1
        time.sleep(random.uniform(0.0, 0.003 if SAFE_MODE else 0.0))
    dur = time.time() - start
    rr = try_get(burst_ep)
    reporter.log("DoS:RateLimit", "GET", "GET", rr, f"{burst_ep}", None, f"blocked={blocked}/{total} in {dur:.2f}s")

def test_idor(reporter: Reporter):
    print("\n[*] IDOR/BOLA ‚Äî par√¢metros sens√≠veis")
    other_id      = str(TEST_USER_ID + 99999)
    random_uuid   = str(uuid.uuid4())
    weird_id      = "1234../.."
    combos = [
        ("valid_self", str(TEST_USER_ID)),
        ("other_user", other_id),
        ("uuid_v4", random_uuid),
        ("weird_chars", weird_id),
    ]
    for endpoint in TEST_ENDPOINTS:
        base = urljoin(BASE_URL, norm_endpoint(endpoint))
        for label, val in combos:
            for key in SENSITIVE_ID_KEYS:
                qs = f"?{quote(key)}={quote(val)}"
                url = base + qs
                r, dt = timed_call("GET", url)
                reporter.log(f"IDOR:{key}:{label}", "GET", "GET", r, url, dt)
                jitter_sleep()

    print("[*] IDOR/BOLA ‚Äî POST com chaves sens√≠veis (sem CSRF)")
    for endpoint in TEST_ENDPOINTS:
        url = urljoin(BASE_URL, norm_endpoint(endpoint))
        for label, val in combos:
            data = {random.choice(SENSITIVE_ID_KEYS): val, "acao": "editar"}
            r, dt = timed_call("POST", url, data=data)
            reporter.log(f"IDOR:POST:{label}", "POST", "POST", r, url, dt)
            jitter_sleep()

def test_idor_confirm(reporter: Reporter):
    print("\n[*] IDOR ‚Äî confirma√ß√£o (hash de corpo)")
    for ep in TEST_ENDPOINTS:
        base = urljoin(BASE_URL, norm_endpoint(ep))
        mine_url  = f"{base}?user_id={TEST_USER_ID}"
        other_url = f"{base}?user_id={TEST_USER_ID+99999}"
        r1, d1 = timed_call("GET", mine_url)
        r2, d2 = timed_call("GET", other_url)
        if r1 and r2 and r1.status_code==200 and r2.status_code==200:
            s1, s2 = body_sig(r1), body_sig(r2)
            if s1 != s2:
                reporter.log("IDOR:delta", "GET", "GET", r2, other_url, d2, note="hash changed; revisar owner check")

def test_cors(reporter: Reporter):
    print("\n[*] CORS (deny-by-default + allow-list)")
    test_origins = _origin_default() + ["null"]
    for endpoint in TEST_ENDPOINTS[:10]:
        url = urljoin(BASE_URL, norm_endpoint(endpoint))
        for origin in test_origins:
            headers = {"Origin": origin} if origin != "null" else {"Origin": "null"}
            r, dt = timed_call("GET", url, headers=headers, allow_redirects=False)
            reporter.log("CORS", "GET", "GET", r, f"{url} (Origin={origin})", dt)

def test_cors_preflight(reporter: Reporter):
    print("\n[*] CORS Preflight + Credenciais")
    for ep in TEST_ENDPOINTS[:10]:
        url = urljoin(BASE_URL, norm_endpoint(ep))
        hdrs = {
            "Origin": BASE_URL.rstrip("/"),
            "Access-Control-Request-Method": "POST",
            "Access-Control-Request-Headers": "content-type,authorization",
        }
        r, dt = timed_call("OPTIONS", url, headers=hdrs, allow_redirects=False)
        reporter.log("CORS:Preflight", "OPTIONS", "OPTIONS", r, url, dt)
        r2, dt2 = timed_call("GET", url, headers={"Origin": BASE_URL.rstrip("/")}, allow_redirects=False)
        reporter.log("CORS:Creds", "GET", "GET", r2, url, dt2)

def test_open_redirect(reporter: Reporter):
    print("\n[*] Open Redirect (b√°sico)")
    for endpoint in TEST_ENDPOINTS:
        base = urljoin(BASE_URL, norm_endpoint(endpoint))
        for p in OPENREDIR_PARAMS:
            for v in OPENREDIR_VALUES:
                url = f"{base}?{p}={quote(v, safe='/:%')}"
                r, dt = timed_call("GET", url, allow_redirects=False)
                reporter.log("OpenRedirect", "GET", "GET", r, url, dt)

def test_security_headers_presence(reporter: Reporter):
    print("\n[*] Headers de Seguran√ßa (presen√ßa)")
    keys = ("Content-Security-Policy", "X-Frame-Options", "X-Content-Type-Options")
    for endpoint in TEST_ENDPOINTS[:12]:
        url = urljoin(BASE_URL, norm_endpoint(endpoint))
        r, dt = timed_call("GET", url, allow_redirects=False)
        present = []
        if r:
            for k in keys:
                if k in r.headers:
                    present.append(k)
        note = "has=" + ",".join(present)
        reporter.log("SecHeaders", "GET", "GET", r, f"{url} ({note})", dt)

def test_security_headers_strict(reporter: Reporter):
    print("\n[*] Security headers ‚Äî rigor (CSP/XFO/XCTO/HSTS/Referrer/Permissions)")
    url = BASE_URL
    r, dt = timed_call("GET", url, allow_redirects=False)
    issues = []
    h = r.headers if r else {}
    csp = h.get("Content-Security-Policy")
    if not csp or "default-src" not in csp:
        issues.append("CSP ausente/fraco (default-src)")
    if h.get("X-Content-Type-Options") != "nosniff":
        issues.append("XCTO != nosniff")
    if h.get("X-Frame-Options") not in ("DENY","SAMEORIGIN"):
        issues.append("XFO ausente/fraco")
    if "Strict-Transport-Security" not in h and BASE_URL.startswith("https"):
        issues.append("HSTS ausente (site https)")
    if "Referrer-Policy" not in h:
        issues.append("Referrer-Policy ausente")
    if "Permissions-Policy" not in h:
        issues.append("Permissions-Policy ausente")
    reporter.log("SecHeaders:Strict", "GET", "GET", r, url, dt, note="; ".join(issues) if issues else "ok")

def test_host_header_injection(reporter: Reporter):
    print("\n[*] Host Header anomalies")
    weird_hosts = ["evil.example", "127.0.0.1:81", " bad host "]
    for endpoint in TEST_ENDPOINTS[:8]:
        url = urljoin(BASE_URL, norm_endpoint(endpoint))
        for h in weird_hosts:
            r, dt = timed_call("GET", url, headers={"Host": h}, allow_redirects=False)
            reporter.log("HostHeader", "GET", "GET", r, f"{url} (Host={h})", dt)

def test_cache_poisoning(reporter: Reporter):
    print("\n[*] Cache Poisoning b√°sico")
    variants = [{"Accept": "text/plain"}, {"Accept": "application/json"}, {"Accept-Language": "pt-BR"}, {"Accept-Language": "en-US"}]
    for endpoint in TEST_ENDPOINTS[:8]:
        url = urljoin(BASE_URL, norm_endpoint(endpoint))
        bodies = []
        last_r = None
        for h in variants:
            r, dt = timed_call("GET", url, headers=h, allow_redirects=False)
            bodies.append((list(h.keys())[0], (r.text[:80] if (r and r.text) else "")))
            last_r = r
            jitter_sleep()
        reporter.log("CachePoison", "GET", "GET", last_r, f"{url} bodies={bodies}", None)

def test_content_type_enforcement(reporter: Reporter):
    print("\n[*] Content-Type enforcement")
    for ep in JSON_PROBE_ENDPOINTS:
        url = urljoin(BASE_URL, norm_endpoint(ep))
        r, dt = timed_call("POST", url, data={"ok":"1"}, headers={"Content-Type": "application/x-www-form-urlencoded"}, allow_redirects=False)
        reporter.log("CT-Enforce:JSONPath", "POST", "POST", r, url, dt)
        r2, dt2 = timed_call("POSTJSON", url, json_body={"ping":"pong"}, allow_redirects=False)
        reporter.log("CT-Enforce:JSONPath(ok)", "POST", "POST", r2, url, dt2)
    for ep in FORM_PROBE_ENDPOINTS:
        url = urljoin(BASE_URL, norm_endpoint(ep))
        r, dt = timed_call("POSTJSON", url, json_body={"ping":"pong"}, allow_redirects=False)
        reporter.log("CT-Enforce:FORMPath", "POST", "POST", r, url, dt)

def test_upload_policy(reporter: Reporter):
    print("\n[*] Pol√≠tica de Upload")
    if not UPLOAD_ENDPOINT:
        reporter.log("UploadPolicy", "POST", "POST", None, "PT_UPLOAD_ENDPOINT n√£o configurado ‚Äî pulando")
        return
    url = urljoin(BASE_URL, norm_endpoint(UPLOAD_ENDPOINT))
    # sem arquivo
    r, dt = timed_call("POST", url, headers=None, allow_redirects=False)
    reporter.log("UploadPolicy:missingFile", "POST", "POST", r, url, dt)
    # arquivo n√£o-PDF
    files = {"file": ("evil.txt", b"not a pdf", "text/plain")}
    r2 = try_post(url, files=files, allow_redirects=False)
    reporter.log("UploadPolicy:nonPDF", "POST", "POST", r2, url)

def test_ssrf_policy(reporter: Reporter):
    print("\n[*] SSRF (defensivo)")
    if not SSRF_ENDPOINTS:
        reporter.log("SSRF-Policy", "GET", "GET", None, "PT_SSRF_ENDPOINTS n√£o configurado ‚Äî pulando")
        return
    bads = PAYLOADS["SSRF"]
    for endpoint in SSRF_ENDPOINTS:
        base = urljoin(BASE_URL, norm_endpoint(endpoint))
        for b in bads:
            sep = "&" if "?" in base else "?"
            url = f"{base}{sep}url={quote(b, safe=':/@[]')}"
            r, dt = timed_call("GET", url, allow_redirects=False)
            reporter.log("SSRF-Policy", "GET", "GET", r, url, dt)
            jitter_sleep()

def test_jwt_basics(reporter: Reporter):
    print("\n[*] JWT (b√°sico)")
    if not JWT_PROBE_ENDPOINT:
        reporter.log("JWT", "GET", "GET", None, "PT_JWT_PROBE_ENDPOINT n√£o configurado ‚Äî pulando")
        return
    url = urljoin(BASE_URL, norm_endpoint(JWT_PROBE_ENDPOINT))
    r, dt = timed_call("GET", url, allow_redirects=False)
    reporter.log("JWT:NoToken", "GET", "GET", r, url, dt)
    jitter_sleep()
    r2, dt2 = timed_call("GET", url, headers={"Authorization": "Bearer invalid.invalid.invalid"}, allow_redirects=False)
    reporter.log("JWT:BadToken", "GET", "GET", r2, url, dt2)
    jitter_sleep()
    alg_none = "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiZ3Vlc3QifQ."
    r3, dt3 = timed_call("GET", url, headers={"Authorization": f"Bearer {alg_none}"}, allow_redirects=False)
    reporter.log("JWT:alg=none", "GET", "GET", r3, url, dt3)
    expired_payload = base64.urlsafe_b64encode(json.dumps({"sub":"guest","exp":int(time.time())-3600}).encode()).rstrip(b"=").decode()
    expired = f"eyJhbGciOiJub25lIn0.{expired_payload}."
    r4, dt4 = timed_call("GET", url, headers={"Authorization": f"Bearer {expired}"}, allow_redirects=False)
    reporter.log("JWT:expired", "GET", "GET", r4, url, dt4)
    if JWT_BEARER_VALID:
        r5, dt5 = timed_call("GET", url, headers={"Authorization": f"Bearer {JWT_BEARER_VALID}"}, allow_redirects=False)
        reporter.log("JWT:GoodToken", "GET", "GET", r5, url, dt5)

def test_xxe_real(reporter: Reporter):
    print("\n[*] XXE real (application/xml)")
    xml = """<?xml version="1.0"?>
    <!DOCTYPE r [<!ENTITY xxe SYSTEM "file:///etc/hosts">]>
    <r>&xxe;</r>"""
    for ep in TEST_ENDPOINTS[:6]:
        url = urljoin(BASE_URL, norm_endpoint(ep))
        r = try_post(url, data=xml, headers={"Content-Type":"application/xml"})
        reporter.log("XXE", "POST", "POST", r, url)

def test_dom_xss_optional(reporter: Reporter):
    print("\n[*] DOM XSS (opcional) ‚Äî requer playwright. Pulando se n√£o instalado.")
    try:
        from playwright.sync_api import sync_playwright  # type: ignore
    except Exception:
        reporter.log("DOM XSS", "HEADLESS", "GET", None, "Playwright n√£o instalado ‚Äî pulando")
        return
    payloads = PAYLOADS["DOM XSS"]
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()
        for payload in payloads[:4]:
            for ep in TEST_ENDPOINTS[:4]:
                url = urljoin(BASE_URL, f"{norm_endpoint(ep)}?q={quote(payload)}")
                try:
                    page.goto(url, wait_until="domcontentloaded", timeout=TIMEOUT*1000)
                    content = page.content()
                    note = "loaded; check manually (headless)"
                    reporter.log("DOM XSS", "HEADLESS", "GET", None, url, note=note)
                except Exception as e:
                    reporter.log("DOM XSS", "HEADLESS", "GET", None, url, note=f"error {e}")
        browser.close()

# =========================
# MELHORIAS ‚Äî NOVAS FUN√á√ïES
# =========================
def latency_baseline(endpoints, samples=5):
    ref = {}
    for ep in endpoints[:10]:
        url = urljoin(BASE_URL, norm_endpoint(ep))
        arr = []
        for _ in range(samples):
            r, dt = timed_call("GET", url, allow_redirects=False)
            arr.append(dt)
            time.sleep(0.03)
        arr.sort()
        ref[url] = (statistics.mean(arr), arr[int(0.95*(len(arr)-1))] if len(arr) > 1 else statistics.mean(arr))
    return ref

def test_sqli_time_based(reporter: Reporter, baseline):
    print("\n[*] SQLi time-based com baseline/p95")
    sleepers = ["SLEEP(3)", "AND SLEEP(4)", "1' OR SLEEP(3)-- -"]
    for ep in TEST_ENDPOINTS[:12]:
        base = urljoin(BASE_URL, norm_endpoint(ep))
        for p in PARAM_NAMES[:2]:
            for payload in sleepers:
                url = f"{base}?{p}={quote(payload)}"
                r, dt = timed_call("GET", url, allow_redirects=False)
                mean, p95 = baseline.get(base, (0.25, 0.4))
                suspicious = dt > max(p95*2.5, mean+2.0)
                note = f"baseline_mean={mean:.2f}s p95={p95:.2f}s"
                if suspicious and r is not None:
                    note += " | POSS√çVEL SQLi time-based"
                reporter.log("SQLi:Time", "GET", "GET", r, url, dt, note)
                jitter_sleep()

def _reflected(html_text, marker):
    if not html_text:
        return False
    return marker in html_text

def test_xss_reflection(reporter: Reporter):
    print("\n[*] XSS refletido ‚Äî verifica√ß√£o de eco sem encoding")
    marker = f"<svg onload=alert({random.randint(100,999)})>"
    for ep in TEST_ENDPOINTS[:12]:
        base = urljoin(BASE_URL, norm_endpoint(ep))
        url = f"{base}?q={quote(marker)}"
        r, dt = timed_call("GET", url, allow_redirects=True)
        note = ""
        if r is not None and r.status_code == 200 and _reflected(r.text, marker):
            note = "REFLEXO DETECTADO ‚Äî sanitiza√ß√£o ausente"
        reporter.log("XSS:Reflected", "GET", "GET", r, url, dt, note)
        jitter_sleep()

def _is_external_redirect(loc: str) -> bool:
    try:
        if not loc:
            return False
        u = urlparse(loc)
        if u.scheme in ("http","https"):
            base_host = urlparse(BASE_URL).netloc.lower()
            return (u.netloc.lower() != base_host)
        if loc.lstrip().startswith(("//","javascript:","data:","http:/\\","https:/\\")):
            return True
        return False
    except Exception:
        return False

def test_open_redirect_strict(reporter: Reporter):
    print("\n[*] Open Redirect ‚Äî valida√ß√£o de Location")
    for endpoint in TEST_ENDPOINTS:
        base = urljoin(BASE_URL, norm_endpoint(endpoint))
        for p in OPENREDIR_PARAMS:
            for v in OPENREDIR_VALUES:
                url = f"{base}?{p}={quote(v, safe='/:%')}"
                r, dt = timed_call("GET", url, allow_redirects=False)
                loc = r.headers.get("Location","") if r else ""
                note = ""
                if r is not None and r.status_code in (301,302,303,307,308) and _is_external_redirect(loc):
                    note = f"OpenRedirect: Location externo ‚Üí {loc[:120]}"
                reporter.log("OpenRedirect:Strict", "GET", "GET", r, url, dt, note)

def test_csrf_strict_origin(reporter: Reporter):
    print("\n[*] CSRF ‚Äî Origin/Referer 'null' e externo")
    bad_origins = ["null", "https://evil.example"]
    for endpoint in TEST_ENDPOINTS:
        url = urljoin(BASE_URL, norm_endpoint(endpoint))
        for o in bad_origins:
            hdrs = {"Origin": o, "Referer": o}
            r, dt = timed_call("POST", url, data={"x":"1"}, headers=hdrs, allow_redirects=False)
            reporter.log("CSRF:OriginCheck", "POST", "POST", r, f"{url} (Origin={o})", dt, "esperado 403/Origin check")
            jitter_sleep()

def _get_set_cookie_headers(resp):
    vals = []
    if resp is None:
        return vals
    try:
        vals = list(resp.raw.headers.get_all("Set-Cookie"))  # type: ignore
        if vals:
            return vals
    except Exception:
        pass
    sc = resp.headers.get("Set-Cookie")
    return [sc] if sc else []

def test_cookie_flags(reporter: Reporter):
    print("\n[*] Cookies ‚Äî HttpOnly/Secure/SameSite")
    r, dt = timed_call("GET", BASE_URL, allow_redirects=True)
    issues = []
    if r:
        all_sc = _get_set_cookie_headers(r)
        for sc in all_sc:
            s = (sc or "").lower()
            name = (sc.split("=",1)[0] if sc else "cookie")
            if "httponly" not in s: issues.append(f"{name}: sem HttpOnly")
            if BASE_URL.startswith("https") and "secure" not in s: issues.append(f"{name}: sem Secure")
            if "samesite" not in s: issues.append(f"{name}: sem SameSite")
    reporter.log("Cookies:Flags", "GET", "GET", r, BASE_URL, dt, "; ".join(issues) if issues else "ok")

def test_hpp(reporter: Reporter):
    print("\n[*] HPP ‚Äî par√¢metros duplicados")
    for ep in TEST_ENDPOINTS[:10]:
        base = urljoin(BASE_URL, norm_endpoint(ep))
        p = random.choice(PARAM_NAMES)
        url = f"{base}?{p}=A&{p}=B&{p}[]=C&{p}=%3Cscript%3E"
        r, dt = timed_call("GET", url, allow_redirects=False)
        reporter.log("HPP", "GET", "GET", r, url, dt, "duplicados/arrays/injection")

def test_crlf_injection(reporter: Reporter):
    print("\n[*] CRLF Injection ‚Äî header splitting")
    bad = "%0d%0aSet-Cookie:%20evil=1"
    for ep in TEST_ENDPOINTS[:8]:
        base = urljoin(BASE_URL, norm_endpoint(ep))
        url = f"{base}?next=/{bad}"
        r, dt = timed_call("GET", url, allow_redirects=False)
        suspicious = False
        if r:
            loc = r.headers.get("Location","")
            if "\r\n" in loc:
                suspicious = True
        note = "POTENCIAL CRLF" if suspicious else ""
        reporter.log("CRLF", "GET", "GET", r, url, dt, note)

def test_jwt_advanced(reporter: Reporter):
    print("\n[*] JWT ‚Äî vetores adicionais (nega√ß√£o esperada)")
    if not JWT_PROBE_ENDPOINT:
        reporter.log("JWT:Advanced", "GET", "GET", None, "PT_JWT_PROBE_ENDPOINT n√£o configurado ‚Äî pulando")
        return
    url = urljoin(BASE_URL, norm_endpoint(JWT_PROBE_ENDPOINT))
    # JWK injection dummy
    hdr = base64.urlsafe_b64encode(json.dumps({"alg":"RS256","jwk":{"kty":"oct","k":"AAAA"}}).encode()).rstrip(b"=").decode()
    pl  = base64.urlsafe_b64encode(json.dumps({"sub":"guest","iat":int(time.time())}).encode()).rstrip(b"=").decode()
    jwk_inj = f"{hdr}.{pl}."
    r1, d1 = timed_call("GET", url, headers={"Authorization": f"Bearer {jwk_inj}"}, allow_redirects=False)
    reporter.log("JWT:JWKinj", "GET", "GET", r1, url, d1)

    # kid path traversal (simulado)
    hdr2 = base64.urlsafe_b64encode(json.dumps({"alg":"HS256","kid":"../../../../etc/passwd"}).encode()).rstrip(b"=").decode()
    pl2  = base64.urlsafe_b64encode(json.dumps({"sub":"guest"}).encode()).rstrip(b"=").decode()
    kid_trav = f"{hdr2}.{pl2}.xyz"
    r2, d2 = timed_call("GET", url, headers={"Authorization": f"Bearer {kid_trav}"}, allow_redirects=False)
    reporter.log("JWT:kidTraversal", "GET", "GET", r2, url, d2)

    # RS/HS confus√£o (token sem assinatura v√°lida)
    hdr3 = base64.urlsafe_b64encode(json.dumps({"alg":"HS256"}).encode()).rstrip(b"=").decode()
    conf = f"{hdr3}.{pl}.aaa"
    r3, d3 = timed_call("GET", url, headers={"Authorization": f"Bearer {conf}"}, allow_redirects=False)
    reporter.log("JWT:AlgConfusion", "GET", "GET", r3, url, d3)

def test_signed_pdf_tampering(reporter: Reporter):
    print("\n[*] Signed PDF ‚Äî tampering (exp/user/att/sig)")
    ok_url = signed_pdf_url(TEST_ATTACHMENT_ID, TEST_USER_ID)
    r0, d0 = timed_call("GET", ok_url, allow_redirects=False)
    reporter.log("SignedPDF:OK", "GET", "GET", r0, ok_url, d0)

    # exp futuro distante / passado
    params = build_signed_pdf_params(TEST_ATTACHMENT_ID, TEST_USER_ID)
    for delta in (3600*24*7, -3600*24*7):
        exp = int(time.time()) + delta
        bad = re.sub(r"exp=\d+", f"exp={exp}", ok_url)
        r, d = timed_call("GET", bad, allow_redirects=False)
        reporter.log("SignedPDF:expTamper", "GET", "GET", r, bad, d, f"delta={delta}")

    # troca user/attachment mantendo sig original (deve falhar)
    for att, usr in ((TEST_ATTACHMENT_ID+1, TEST_USER_ID), (TEST_ATTACHMENT_ID, TEST_USER_ID+1)):
        bad = ok_url.replace(f"/{TEST_ATTACHMENT_ID}/", f"/{att}/").replace(f"user_id={TEST_USER_ID}", f"user_id={usr}")
        r, d = timed_call("GET", bad, allow_redirects=False)
        reporter.log("SignedPDF:idsTamper", "GET", "GET", r, bad, d)

    # sig inv√°lida
    bad = re.sub(r"sig=[0-9a-f]+", "sig=deadbeef", ok_url)
    r, d = timed_call("GET", bad, allow_redirects=False)
    reporter.log("SignedPDF:sigTamper", "GET", "GET", r, bad, d)

def test_cors_semantics(reporter: Reporter):
    print("\n[*] CORS ‚Äî valida√ß√£o sem√¢ntica (* com credenciais)")
    for ep in TEST_ENDPOINTS[:10]:
        url = urljoin(BASE_URL, norm_endpoint(ep))
        r, dt = timed_call("GET", url, headers={"Origin": BASE_URL.rstrip("/")}, allow_redirects=False)
        issues = []
        if r:
            aco = r.headers.get("Access-Control-Allow-Origin","")
            acc = r.headers.get("Access-Control-Allow-Credentials","")
            if acc.lower() == "true" and aco.strip() in ("*", ""):
                issues.append("ACA-Origin='*' com credenciais ‚Äî vulner√°vel")
        reporter.log("CORS:Semantics", "GET", "GET", r, url, dt, "; ".join(issues) if issues else "ok")

def test_dos_burst_concurrent(reporter: Reporter, workers=12):
    print("\n[*] DoS ‚Äî rajada concorrente controlada")
    burst_ep = urljoin(BASE_URL, norm_endpoint(DOS_BURST_ENDPOINT))
    def one():
        try:
            return session.get(burst_ep, verify=VERIFY_TLS, timeout=TIMEOUT)
        except Exception:
            return None
    start = time.time()
    blocked = 0
    total = DOS_RATE_BURST
    with ThreadPoolExecutor(max_workers=workers) as ex:
        futures = [ex.submit(one) for _ in range(total)]
        for fut in as_completed(futures):
            r = fut.result()
            if is_blocked(r) and r.status_code == 429:
                blocked += 1
    dur = time.time() - start
    reporter.log("DoS:ConcurrentBurst", "GET", "GET", None, burst_ep, None, f"blocked={blocked}/{total} in {dur:.2f}s")

# =========================
# Main
# =========================
def main():
    print("[üöÄ] Pentest de Seguran√ßa ‚Äî WAF (completo++)")
    ok = login()
    if not ok:
        print("\n[!] Login n√£o confirmado. Algumas rotas podem redirecionar para /login ou negar acesso.")

    reporter = Reporter()
    try:
        # Base original
        test_payload_matrix_enhanced(reporter)
        test_qs_raw_guard(reporter)
        test_csrf(reporter)
        test_signed_pdf(reporter)
        test_idor(reporter)
        test_idor_confirm(reporter)
        test_dos(reporter)
        test_cors(reporter)
        test_cors_preflight(reporter)
        test_open_redirect(reporter)
        test_security_headers_presence(reporter)
        test_security_headers_strict(reporter)
        test_host_header_injection(reporter)
        test_cache_poisoning(reporter)
        test_content_type_enforcement(reporter)
        test_upload_policy(reporter)
        test_ssrf_policy(reporter)
        test_jwt_basics(reporter)
        test_xxe_real(reporter)
        test_dom_xss_optional(reporter)

        baseline = latency_baseline(TEST_ENDPOINTS)
        test_sqli_time_based(reporter, baseline)
        test_xss_reflection(reporter)
        test_open_redirect_strict(reporter)
        test_csrf_strict_origin(reporter)
        test_cookie_flags(reporter)
        test_hpp(reporter)
        test_crlf_injection(reporter)
        test_jwt_advanced(reporter)
        test_signed_pdf_tampering(reporter)
        test_cors_semantics(reporter)
        test_dos_burst_concurrent(reporter)

    finally:
        reporter.summary()
        print("[‚úÖ] Testes conclu√≠dos")

if __name__ == "__main__":
    main()
